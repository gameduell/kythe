// Code generated by protoc-gen-go.
// source: kythe/proto/xref.proto
// DO NOT EDIT!

/*
Package xref_proto is a generated protocol buffer package.

It is generated from these files:
	kythe/proto/xref.proto

It has these top-level messages:
	NodesRequest
	NodeInfo
	NodesReply
	EdgesRequest
	EdgeSet
	EdgesReply
	Fact
	Location
	DecorationsRequest
	DecorationsReply
*/
package xref_proto

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type Location_Kind int32

const (
	// The entire file; the start and end fields are ignored.
	Location_FILE Location_Kind = 0
	// The point or span of file subtended by start and end.
	Location_SPAN Location_Kind = 1
)

var Location_Kind_name = map[int32]string{
	0: "FILE",
	1: "SPAN",
}
var Location_Kind_value = map[string]int32{
	"FILE": 0,
	"SPAN": 1,
}

func (x Location_Kind) String() string {
	return proto.EnumName(Location_Kind_name, int32(x))
}

type NodesRequest struct {
	// The tickets of the nodes to be looked up.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, all available facts
	// are returned for each matching node.  The filter applies to ALL requested
	// nodes.  For different filters per node, the client must issue separate
	// requests.  See EdgesRequest for the format of the filter globs.
	Filter []string `protobuf:"bytes,2,rep,name=filter" json:"filter,omitempty"`
}

func (m *NodesRequest) Reset()         { *m = NodesRequest{} }
func (m *NodesRequest) String() string { return proto.CompactTextString(m) }
func (*NodesRequest) ProtoMessage()    {}

type NodeInfo struct {
	Ticket string  `protobuf:"bytes,1,opt,name=ticket" json:"ticket,omitempty"`
	Fact   []*Fact `protobuf:"bytes,2,rep,name=fact" json:"fact,omitempty"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}

func (m *NodeInfo) GetFact() []*Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

type NodesReply struct {
	// One NodeInfo is returned for each requested node that had a non-zero
	// number of matching facts.
	Node []*NodeInfo `protobuf:"bytes,1,rep,name=node" json:"node,omitempty"`
}

func (m *NodesReply) Reset()         { *m = NodesReply{} }
func (m *NodesReply) String() string { return proto.CompactTextString(m) }
func (*NodesReply) ProtoMessage()    {}

func (m *NodesReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

type EdgesRequest struct {
	// The tickets of the source nodes for which edges are requested.
	// The service will return an error if no tickets are specified.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// The kinds of outbound edges that should be returned for each matching
	// source node.  If empty, all available edge kinds are returned.
	Kind []string `protobuf:"bytes,2,rep,name=kind" json:"kind,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for the target node of each matching edge.  If filter is empty,
	// no facts are returned.
	//
	// The supported glob operators are:
	//   *   zero or more non-slash characters ([^/]*)
	//   ?   any single non-slash character ([^/])
	//   **  zero or more of any character (.*)
	//
	// All other characters match literally, and the glob must consume the entire
	// name in order to match.  The facts returned are the union of those matched
	// by all the globs provided.
	Filter []string `protobuf:"bytes,3,rep,name=filter" json:"filter,omitempty"`
	// The edges matching a request are organized into logical pages.  The size
	// of each page is a number of distinct edges.  Notionally: All the matching
	// edges are ordered lexicographically by (start_ticket, kind, end_ticket);
	// the page_token determines where in the ordering to start, and page_size
	// determines how many edges should be returned.
	//
	// If page_token is empty, edges will be returned starting at the beginning
	// of the sequence; otherwise the starting point named by the page_token will
	// be used.  Legal values of page_token are returned by the server in the
	// next_page_token field of the EdgesReply.  A page token should be treated
	// as an opaque value by the client, and is valid only relative to a
	// particular set of tickets and kinds.  If an invalid page token is
	// requested, the server will return an error.
	//
	// If page_size > 0, at most that number of edges will be returned by the
	// service for this request (see EdgeSet and EdgesReply below).
	// If page_size = 0, the default, the server will assume a reasonable default
	// page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer edges than the requested page_size,
	// even if more are available, save that it must return at least 1 edge if
	// any are available at all.
	PageSize  int32  `protobuf:"varint,8,opt,name=page_size" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,9,opt,name=page_token" json:"page_token,omitempty"`
}

func (m *EdgesRequest) Reset()         { *m = EdgesRequest{} }
func (m *EdgesRequest) String() string { return proto.CompactTextString(m) }
func (*EdgesRequest) ProtoMessage()    {}

// An EdgeSet represents a collection of edges outbound from a single node.
// The edges are organized into groups, each sharing a common edge kind.
//
// The number of edges represented by an EdgeSet es, denoted len(es), is the
// sum of the lengths of the repeated target_ticket fields for all the groups
// in the EdgeSet.  This count is used to determine page size in a request.
//
// TODO(fromberger): Sort out what to do about the rare case of facts attached
// to edges.
type EdgeSet struct {
	// The ticket of the source node for all the edges in the edge set.
	SourceTicket string `protobuf:"bytes,1,opt,name=source_ticket" json:"source_ticket,omitempty"`
	// Each group is a collection of outbound edges from source node sharing a
	// given kind.  In a given EdgeSet, the server will not send more than one
	// group with the same kind label.
	Group []*EdgeSet_Group `protobuf:"bytes,2,rep,name=group" json:"group,omitempty"`
}

func (m *EdgeSet) Reset()         { *m = EdgeSet{} }
func (m *EdgeSet) String() string { return proto.CompactTextString(m) }
func (*EdgeSet) ProtoMessage()    {}

func (m *EdgeSet) GetGroup() []*EdgeSet_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type EdgeSet_Group struct {
	Kind         string   `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	TargetTicket []string `protobuf:"bytes,2,rep,name=target_ticket" json:"target_ticket,omitempty"`
}

func (m *EdgeSet_Group) Reset()         { *m = EdgeSet_Group{} }
func (m *EdgeSet_Group) String() string { return proto.CompactTextString(m) }
func (*EdgeSet_Group) ProtoMessage()    {}

type EdgesReply struct {
	// This field will contain one EdgeSet for each source node with one or more
	// matching outbound edges.  The number of edges represented by an EdgesReply
	// er, denoted len(er), is the sum of len(es) for each es in edgeset.  This
	// count is used to determine the page size.
	EdgeSet []*EdgeSet `protobuf:"bytes,1,rep,name=edge_set" json:"edge_set,omitempty"`
	// This field will contain one entry for each distinct node referenced by
	// some edge in edgesets, for which there is one or more matching facts.
	//
	// Rationale: This prevents us from having to copy the data to all the end
	// nodes, but allows the client to have that information without making
	// additional requests.
	Node []*NodeInfo `protobuf:"bytes,2,rep,name=node" json:"node,omitempty"`
	// If there are additional pages of edges after the ones returned in this
	// reply, next_page_token is the page token that may be passed to fetch the
	// next page in sequence after this one.  If there are no additional edges,
	// this field will be empty.
	NextPageToken string `protobuf:"bytes,9,opt,name=next_page_token" json:"next_page_token,omitempty"`
}

func (m *EdgesReply) Reset()         { *m = EdgesReply{} }
func (m *EdgesReply) String() string { return proto.CompactTextString(m) }
func (*EdgesReply) ProtoMessage()    {}

func (m *EdgesReply) GetEdgeSet() []*EdgeSet {
	if m != nil {
		return m.EdgeSet
	}
	return nil
}

func (m *EdgesReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

// Fact represents a single key/value fact from the graph.
type Fact struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Fact) Reset()         { *m = Fact{} }
func (m *Fact) String() string { return proto.CompactTextString(m) }
func (*Fact) ProtoMessage()    {}

// A Location represents a single span of zero or more contiguous bytes of a
// file or buffer.  An empty LOCATION denotes the entirety of the referenced
// file or buffer.
//
type Location struct {
	// The ticket of the file this location belongs to.  If the location
	// represents a memory buffer, the ticket should be omitted.
	Ticket string `protobuf:"bytes,1,opt,name=ticket" json:"ticket,omitempty"`
	// What kind of location this is.
	Kind Location_Kind `protobuf:"varint,2,opt,name=kind,enum=kythe.proto.Location_Kind" json:"kind,omitempty"`
	// The starting point of the location.
	Start *Location_Point `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	// The ending point of the location.
	End *Location_Point `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}

func (m *Location) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Location) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

// A Point represents a location within a file or buffer.
//
// If line_number ≤ 0, the line number and column offset are considered
// unknown and will be ignored.
//
// A point with line_number > 0 is said to be _normalized_ if it satisfies
// the constraint 0 ≤ column_offset ≤ bytelen(line_number); that is, if the
// column_offset is within the actual range of the corresponding line.  A
// point can be normalized by adjusting line_number and column_offset so that
// this constraint is satisfied.  This may be impossible if the column offset
// exceeds the bounds of the file.
type Location_Point struct {
	// The offset in bytes from the beginning of the file.
	// Requires 0 ≤ byte_offset ≤ len(file).
	ByteOffset int32 `protobuf:"varint,1,opt,name=byte_offset" json:"byte_offset,omitempty"`
	// The line number containing the point, 1-based.
	LineNumber int32 `protobuf:"varint,2,opt,name=line_number" json:"line_number,omitempty"`
	// The byte offset of the point within its line.
	ColumnOffset int32 `protobuf:"varint,3,opt,name=column_offset" json:"column_offset,omitempty"`
}

func (m *Location_Point) Reset()         { *m = Location_Point{} }
func (m *Location_Point) String() string { return proto.CompactTextString(m) }
func (*Location_Point) ProtoMessage()    {}

type DecorationsRequest struct {
	// The location of the file to fetch decorations for.  The ticket of location
	// must be non-empty.
	//
	// If the location is a SPAN, decorations are only returned for the specified
	// window of the file.  It is an error in any case if location is invalid.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// If dirty_buffer is non-empty, the results will be adjusted (patched) to
	// account for the regions of the specified file differing from the contents
	// of the dirty buffer.
	DirtyBuffer []byte `protobuf:"bytes,2,opt,name=dirty_buffer,proto3" json:"dirty_buffer,omitempty"`
	// If true, return the encoded source text for the selected window.  Source
	// text is not affected by patching.
	SourceText bool `protobuf:"varint,3,opt,name=source_text" json:"source_text,omitempty"`
	// If true, return reference edges whose source nodes are located in the
	// selected window.  References are affected by patching.
	References bool `protobuf:"varint,4,opt,name=references" json:"references,omitempty"`
}

func (m *DecorationsRequest) Reset()         { *m = DecorationsRequest{} }
func (m *DecorationsRequest) String() string { return proto.CompactTextString(m) }
func (*DecorationsRequest) ProtoMessage()    {}

func (m *DecorationsRequest) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

type DecorationsReply struct {
	// The normalized location for which decorations are returned.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The encoded source text for the selected window.
	SourceText []byte `protobuf:"bytes,2,opt,name=source_text,proto3" json:"source_text,omitempty"`
	Encoding   string `protobuf:"bytes,3,opt,name=encoding" json:"encoding,omitempty"`
	// The reference edges located in the specified window.
	Reference []*DecorationsReply_Reference `protobuf:"bytes,4,rep,name=reference" json:"reference,omitempty"`
	// This field will contain one entry for each distinct node referenced by a
	// reference edge.
	Node []*NodeInfo `protobuf:"bytes,15,rep,name=node" json:"node,omitempty"`
}

func (m *DecorationsReply) Reset()         { *m = DecorationsReply{} }
func (m *DecorationsReply) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply) ProtoMessage()    {}

func (m *DecorationsReply) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DecorationsReply) GetReference() []*DecorationsReply_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *DecorationsReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

// Represents a reference edge source ---KIND---> target.
type DecorationsReply_Reference struct {
	SourceTicket string `protobuf:"bytes,1,opt,name=source_ticket" json:"source_ticket,omitempty"`
	TargetTicket string `protobuf:"bytes,2,opt,name=target_ticket" json:"target_ticket,omitempty"`
	Kind         string `protobuf:"bytes,3,opt,name=kind" json:"kind,omitempty"`
}

func (m *DecorationsReply_Reference) Reset()         { *m = DecorationsReply_Reference{} }
func (m *DecorationsReply_Reference) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply_Reference) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("kythe.proto.Location_Kind", Location_Kind_name, Location_Kind_value)
}

// Client API for XRefService service

type XRefServiceClient interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error)
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error)
}

type xRefServiceClient struct {
	cc *grpc.ClientConn
}

func NewXRefServiceClient(cc *grpc.ClientConn) XRefServiceClient {
	return &xRefServiceClient{cc}
}

func (c *xRefServiceClient) Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error) {
	out := new(NodesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Nodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error) {
	out := new(EdgesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Edges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error) {
	out := new(DecorationsReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Decorations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for XRefService service

type XRefServiceServer interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(context.Context, *NodesRequest) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(context.Context, *EdgesRequest) (*EdgesReply, error)
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(context.Context, *DecorationsRequest) (*DecorationsReply, error)
}

func RegisterXRefServiceServer(s *grpc.Server, srv XRefServiceServer) {
	s.RegisterService(&_XRefService_serviceDesc, srv)
}

func _XRefService_Nodes_Handler(srv interface{}, ctx context.Context, buf []byte) (proto.Message, error) {
	in := new(NodesRequest)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Nodes(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_Edges_Handler(srv interface{}, ctx context.Context, buf []byte) (proto.Message, error) {
	in := new(EdgesRequest)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Edges(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_Decorations_Handler(srv interface{}, ctx context.Context, buf []byte) (proto.Message, error) {
	in := new(DecorationsRequest)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Decorations(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _XRefService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.XRefService",
	HandlerType: (*XRefServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Nodes",
			Handler:    _XRefService_Nodes_Handler,
		},
		{
			MethodName: "Edges",
			Handler:    _XRefService_Edges_Handler,
		},
		{
			MethodName: "Decorations",
			Handler:    _XRefService_Decorations_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
